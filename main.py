# -*- coding: utf-8 -*-
"""Untitled7.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/187s-KEpTsyXTKQNlAvgGugpMkuNhw_Zg
"""

!pip install reedsolo

import numpy as np
import scipy.fft
import PIL.Image
import time
from reedsolo import RSCodec, ReedSolomonError
import random
import matplotlib.pyplot as plt

# Image Processing Parameters
MCU_SIZE = 8
QUANT_MATRIX = np.array([
    [16, 11, 10, 16, 24, 40, 51, 61],
    [12, 12, 14, 19, 26, 58, 60, 55],
    [14, 13, 16, 24, 40, 57, 69, 56],
    [14, 17, 22, 29, 51, 87, 80, 62],
    [18, 22, 37, 56, 68, 109, 103, 77],
    [24, 35, 55, 64, 81, 104, 113, 92],
    [49, 64, 78, 87, 103, 121, 120, 101],
    [72, 92, 95, 98, 112, 100, 103, 99]
])

# Load image (Replace with your image file path)
test_img = np.array(PIL.Image.open("file_path"))[:, :, 1] / 255
test_height, test_width = test_img.shape
mcu_rows = test_height // MCU_SIZE
mcu_columns = test_width // MCU_SIZE

# Reed-Solomon Codec Initialization
rsc = RSCodec(10)  # Number of ECC symbols

# Define DCT and IDCT functions
def to_dct(data):
    dct = scipy.fft.dct(data, axis=0)
    dct = scipy.fft.dct(dct, axis=1)
    return dct

def from_dct(dct):
    data = scipy.fft.idct(dct, axis=0)
    data = scipy.fft.idct(data, axis=1)
    return data

# Encoding Process
mcu_dct = np.zeros((test_height, test_width))
mcu_quant = np.zeros((test_height, test_width))

for by in range(mcu_rows):
    for bx in range(mcu_columns):
        x_start = bx * MCU_SIZE
        x_end = (bx + 1) * MCU_SIZE
        y_start = by * MCU_SIZE
        y_end = (by + 1) * MCU_SIZE
        block = test_img[y_start:y_end, x_start:x_end]
        dct = to_dct(block)
        quant = np.round(dct / QUANT_MATRIX)
        mcu_quant[y_start:y_end, x_start:x_end] = quant

# Reed-Solomon Encoding
encoded_data = rsc.encode(mcu_quant.tobytes())

# Function to introduce random bit errors
def introduce_errors(data, error_count):
    """Introduce random bit errors into the data."""
    data_array = np.frombuffer(data, dtype=np.uint8)
    total_bits = data_array.size * 8

    # Randomly flip bits
    for _ in range(error_count):
        bit_index = random.randint(0, total_bits - 1)
        byte_index = bit_index // 8
        bit_position = bit_index % 8
        data_array[byte_index] ^= 1 << bit_position

    return data_array.tobytes()

# Simulate Transmission with Errors
error_count = 5  # Number of bits to flip; adjust as needed for testing
transmitted_data = introduce_errors(encoded_data, error_count)

# Reed-Solomon Decoding
try:
    decoded_output = rsc.decode(transmitted_data)
    decoded_data = decoded_output[0]
    mcu_quant = np.frombuffer(decoded_data, dtype=mcu_quant.dtype).reshape(mcu_quant.shape)
except ReedSolomonError:
    print("Reed-Solomon decoding failed")
    mcu_quant = None

# Decoding Process
if mcu_quant is not None:
    mcu_idct = np.zeros((test_height, test_width))
    for by in range(mcu_rows):
        for bx in range(mcu_columns):
            x_start = bx * MCU_SIZE
            x_end = (bx + 1) * MCU_SIZE
            y_start = by * MCU_SIZE
            y_end = (by + 1) * MCU_SIZE
            dequant = mcu_quant[y_start:y_end, x_start:x_end] * QUANT_MATRIX
            mcu_idct[y_start:y_end, x_start:x_end] = from_dct(dequant)

    # Display the processed image
    plt.imshow(mcu_idct, cmap="gray", vmin=0, vmax=1)
    plt.colorbar()
    plt.show()
else:
    print("Decoding failed. Unable to display image.")

